### 浅拷贝与深拷贝
> #### 需要注意的问题
>对象引用中环的处理  
>对 Date, RegExp 的深复制支持  
>ES6引入的大量新的标准对象  
>复制数组的属性  
>保留非源生对象的类型  
>复制不可枚举元素  
>复制函数

#### 方案
* JSON.parse(JSON.stringify(obj))
> ##### 存在问题：
> 1. 只能处理Number, String, Boolean, Array和扁平对象，即那些能够被 json 直接表示的数据结构
>```javascript
>//扁平对象(obj为测试对象)
>toString.call( obj ) === "[object Object]"
>  && Object.getPrototypeof( obj ) === null
>  || (typeof Object.getPrototypeof( obj ) === 'function' 
>       && Object.getPrototypeof( obj ).toString() = Object.toString())
>? 'isPlan' : 'not';
>```
> 2. 会抛弃对象的原型链
> 3. 无法复制RegExp对象
>```javascript
> JSON.stringify({a: /[1-9]*/g});//return "{"a":{}}"
>```
* [Underscore `_.clone()` (浅复制)](https://github.com/jashkenas/underscore/blob/e4743ab712b8ab42ad4ccb48b155034d02394e4d/underscore.js#L1068)
* [jQuery `$.extend(true, {})`](https://github.com/jquery/jquery/blob/1472290917f17af05e98007136096784f9051fab/src/core.js#L121)
```javascript
/**
   * jquery的深拷贝提取
   * 修改基于jquery 3.2.2-pre /src/core.js
   * 
   * @param deep 可选。 Boolean类型 指示是否深度合并对象，默认为false。
   *             如果该值为true，且多个对象的某个同名属性也都是对象，则该"属性对象"的属性也将进行合并。
   *             true:后面的会覆盖前面的值
   *             false:
   * @param clone Object类型 目标对象，其他对象的成员属性将被附加到该对象上。
   * @param copy 可选。 Object类型 第一个被合并的对象。
   * ...
   * @param copyN
   */
  // jQuery.extend = jQuery.fn.extend = function() {
  // function deepclone( deep, clone, copy ) {
  function deepclone() {
    var options, name, src, copy, copyIsArray, clone,
      target = arguments[ 0 ] || {},
      i = 1,
      length = arguments.length,
      deep = false;
    // Handle a deep copy situation
    if ( typeof target === "boolean" ) {
      deep = target;
      // Skip the boolean and the target
      target = arguments[ i ] || {};
      i++;
    }
    // Handle case when target is a string or something (possible in deep copy)
    // if ( typeof target !== "object" && !jQuery.isFunction( target ) ) { 
    if ( typeof target !== "object" && typeof target != "function" ) {
      target = {};
    }
    // Extend jQuery itself if only one argument is passed
    if ( i === length ) {
      target = this;
      i--;
    }
    for ( ; i < length; i++ ) {
      // Only deal with non-null/undefined values
      if ( ( options = arguments[ i ] ) != null ) {
        // Extend the base object
        for ( name in options ) {
          src = target[ name ];
          copy = options[ name ];
          // Prevent never-ending loop
          if ( target === copy ) {
            continue;
          }
          // Recurse if we're merging plain objects or arrays
          // 简单对象
          // if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
          if ( deep && copy && 
            ( isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) )
          {
            if ( copyIsArray ) {
              copyIsArray = false;
              clone = src && Array.isArray( src ) ? src : [];
            } else {
              // clone = src && jQuery.isPlainObject( src ) ? src : {};
              clone = src && isPlainObject( src ) ? src : {};
            }
            // Never move original objects, clone them
            // target[ name ] = jQuery.extend( deep, clone, copy );
            target[ name ] = deepclone( deep, clone, copy );
          // Don't bring in undefined values
          } else if ( copy !== undefined ) {
            target[ name ] = copy;
          }
        }
      }
    }
    // Return the modified object
    return target;
  };
  function isPlainObject( obj ) {
    var proto, Ctor;
    // Detect obvious negatives
    // Use toString instead of jQuery.type to catch host objects
    // 判断obj只是对象类型
    if ( !obj || toString.call( obj ) !== "[object Object]" ) {
      return false;
    }
    // proto = getProto( obj ); 
    proto = Object.getPrototypeOf( obj );
    // Objects with no prototype (e.g., `Object.create( null )`) are plain
    if ( !proto ) {
      return true;
    } 
    // Objects with prototype are plain iff they were constructed by a global Object function
    // Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
    Ctor = proto.hasOwnProperty('constructor') && proto.constructor;
    // return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
    return typeof Ctor === "function" && Ctor.toString() === Object.toString();
  }
  var x = {
    a: 1,
    b: { f: { g: 1 } },
    c: [ 1, 2, 3 ]
  };

  var y = deepclone({}, x),          //shallow copy
    z = deepclone(true, {}, x);    //deep copy

  y.b.f === x.b.f       // true
  z.b.f === x.b.f       // false
```
* lodash `_.clone()/_.cloneDeep()`
* ~~手写到从前~~
```javascript
function deepClone() {
  var copyResult =  {};
  var obj = arguments[0];
  //如果不是对象类型直接返回
  if(toString.call(obj) !== '[object Object]') {
    return obj;
  }
  var copyKeys = Object.keys(obj)
  for(var i = 0; i < copyKeys.length; i++) {
    copyResult[copyKeys[i]] = deepClone(obj[copyKeys[i]]);
  }
  return copyResult;
}
var a = { 1: 1 };
var b = { 2: 2, a };
var c = deepClone(b);
a[ 1 ] = 3;
console.log(b, c);//{ '2': 2, a: { '1': 3 } } { '2': 2, a: { '1': 1 } }```
```
## 基本类型与类型判断函数对应表
||对象({})|函数(function(){})|数组([0, 1, 2])|数字(2)|布尔(true)|undefined|null|字符串('test')|function* a(){}|
|--|--|--|--|--|--|--|--|--|--|
|obj.toString()|[object Object]|function(){}|0,1,2|2|true|err|err|'test'||
|toString.call(obj)|[object Object]|[object Function]|[object Array]|[object Number]|[object Boolean]|[object Undefined]|[object Null]|[object String]|[object GeneratorFunction]|
|typeof obj|object|function|object|number|boolean|undefined|object|string|function|
|Object.getPrototypeOf(obj)|{}|function () { [native code] }|[]|[Number: 0]|[Boolean: false]|`err`|`err`|String {}||
|obj.hasOwnProperty('sth')|true/false|true/false|true/false|false|false|false|false|false||

> 附：  
> a instanceof A：a的原型式A吗？  
> Object.getPrototypeOf(a)：返回a的原型  
> a.hasOwnProperty('b')：a对象中有b属性或方法吗（直接）