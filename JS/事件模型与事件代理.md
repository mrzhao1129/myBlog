## 事件模型与事件代理
### 事件模型
* DOM0

  在HTML标签中直接用，例如：
  ```javascript
  <button onclick="doSomething()"/>
  ```
  或者可以写成：获取dom节点后给onclick函数赋值
  ```javascript
  document.getElementById('button').onclick = function() {};
  ```
* DOM2
  ```javascript
  document.getElementById('button').addEventListener('click', function(e) {}, false);
  ```
  注意：
  1. 先捕获后冒泡（从外到内再到外），在冒泡期间执行事件方法（默认false，true为在捕获期间执行事件方法）
  2. 和DOM0不同，同一个DOM可以绑定多个相同的触发事件而不覆盖（例如多个click，依次执行）
* IE
### 事件代理
  话不多说上代码：
  ```html
  <ul id="parent-ul">
    <li><span>Item 1</span></li>
    <li><span>Item 2</span></li>
    <li><span>Item 3</span></li>
    <li><span>Item 4</span></li>
    <li><span>Item 5</span></li>
    <li><span>Item 6</span></li>
  </ul>
  ```
  ```javascript
  var Dul = document.getElementById('parent-ul');
  var Dlis = Dul.querySelectorAll('li');
  var Dspans = Dul.querySelectorAll('span');
  //涉及到闭包，附两种解决方案：ES6let和闭包。
   for(let i = 0; i < Dlis.length; i++) {
     Dlis[i].onclick = function() { 
       console.log(i)
     }
   }
  //for(var i = 0; i < Dlis.length; i++) {
  //  (function(i) {
  //    Dlis[i].onclick = function() { 
  //      console.log(i)
  //    }
  //  })(i);
  //}
  for(let i = 0; i < Dspans.length; i++) {
    Dspans[i].onclick = function() {
      console.log('in:' + i)
    }
  }
  ```
  这样存在的问题随着列表每次更新，就得跑一次函数绑定，列表长的话是不小的工作量，影响浏览器性能。

  解决方案：
  ```javascript
  Dul.addEventListener('click', function(e) {
    if(e.target && e.target.nodeName === 'SPAN') {
      console.log('span')
    }
    if(e.target && e.target.nodeName === 'LI') {
      console.log('li')
    }
  });
  ```
  注意：不是所有的事件都能冒泡的。blur、focus、load和unload不能像其它事件一样冒泡。事实上blur和focus可以用事件捕获而非事件冒泡的方法获得（在IE之外的其它浏览器中）。 